<html>
<head>
<title>Learn TI-83 Plus Assembly In 28 Days &mdash; Day 25 &mdash; Sprites</title>
<link rel="Stylesheet" href="../stuff/format.css">
</head>

<body>

<div class=NavHeader>
    &middot; <a href="toc.html">Table Of Contents</a>
    &middot; <a href="day24.html">Previous</a>
    &middot; <a href="day26.html">Next</a>
    &middot;
</div>

    <hr>
    <h1>DAY 25. Sprites</h1>
    <hr>
    <b><font color=#CCCCCC>novice intermediate advanced <font color=#CC0000>expert</font></font></b><hr>

<ul class=TopicList>
<li type="disc"><a href="#dat">Sprite Data</a>
<li type="square"><a href="#dis">Displaying Sprites</a>
<li type="disc"><a href="#met">Methods of Displaying Sprites</a>
<li type="square"><a href="#sdr">XOR Sprite Display Routine</a>
<li type="square"><a href="#msk">Masked Sprites</a>
<li type="disc"><a href="#era">Erasing Sprites</a>
<li type="circle"><a href="#clp">Clipping Sprites</a>
<li type="square"><a href="#csx">Clipped XOR Sprite Display Routine</a>
</ul>
    <hr>

Well, I can't tell you how they got the exotic name "sprite", but I can tell you what they are. Roughly, a sprite is an image that moves around the screen. Ever played a video game? Then you've seen hundreds of sprites. In fact, you are looking at a sprite right now. Shake that device in your right hand and watch it dance! :-)<p>

<a name="dat"></a>
<h2>Sprite Data</h2>
How to store a sprite image is the first thing to pin down. It's simple: where the sprite is black, have a 1. Where the sprite is white, have a 0:

<div align=center>
<table>
<tr>
<td height=15 width=15></td>
<td height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td height=15 width=15></td>
<td height=15 width=15></td>
</tr>
<tr>
<td height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td height=15 width=15></td>
</tr>
<tr>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td height=15 width=15></td>
<td height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
</tr>
<tr>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td height=15 width=15></td>
<td height=15 width=15></td>
<td height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
</tr>
<tr>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td height=15 width=15></td>
<td height=15 width=15></td>
<td height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
</tr>
<tr>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td height=15 width=15></td>
<td height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
</tr>
<tr>
<td height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td height=15 width=15></td>
</tr>
<tr>
<td height=15 width=15></td>
<td height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td class=Heading height=15 width=15></td>
<td height=15 width=15></td>
<td height=15 width=15></td>
</tr>
</table>
</div>

Here's what the data would look like:
<div align=center><tt><b>
0 0 1 1 1 1 0 0<br>
0 1 1 1 1 1 1 0<br>
1 1 1 1 0 0 1 1<br>
1 1 1 0 0 0 1 1<br>
1 1 0 0 0 1 1 1<br>
1 1 0 0 1 1 1 1<br>
0 1 1 1 1 1 1 0<br>
0 0 1 1 1 1 0 0</b></tt></div>
Now let's remove the zeros so it looks like something:
<div align=center><tt><b>
&nbsp; &nbsp; 1 1 1 1 &nbsp; &nbsp;<br>
&nbsp; 1 1 1 1 1 1 &nbsp;<br>
1 1 1 1 &nbsp; &nbsp; 1 1<br>
1 1 1 &nbsp; &nbsp; &nbsp; 1 1<br>
1 1 &nbsp; &nbsp; &nbsp; 1 1 1<br>
1 1 &nbsp; &nbsp; 1 1 1 1<br>
&nbsp; 1 1 1 1 1 1 &nbsp;<br>
&nbsp; &nbsp; 1 1 1 1 &nbsp; &nbsp;</b></tt></div><p>

<a name="dis"></a>
<h2>Displaying Sprites</h2>
There is only one hard thing about displaying a sprite, and that is what to do when the sprite is placed so that one row straddles two bytes of the display:

<pre>
xxxxxxxx xxxxxxxx xxxxxxxx xxx00111 100xxxxx xxxxxxxx
xxxxxxxx xxxxxxxx xxxxxxxx xxx01111 110xxxxx xxxxxxxx
xxxxxxxx xxxxxxxx xxxxxxxx xxx11110 011xxxxx xxxxxxxx
xxxxxxxx xxxxxxxx xxxxxxxx xxx11100 011xxxxx xxxxxxxx
xxxxxxxx xxxxxxxx xxxxxxxx xxx11000 111xxxxx xxxxxxxx
xxxxxxxx xxxxxxxx xxxxxxxx xxx11001 111xxxxx xxxxxxxx
xxxxxxxx xxxxxxxx xxxxxxxx xxx01111 110xxxxx xxxxxxxx
xxxxxxxx xxxxxxxx xxxxxxxx xxx00111 100xxxxx xxxxxxxx
</pre>

Cases like these can be remedied through shifting each row of the sprite until it's split appropriately, then bitmasking the split halves into the graph buffer. The amount that the sprite needs to be shifted by is found by dividing its x-compontent by 8 and taking the remainder. In this case, the sprite should be shifted by 27 % 8 = 3 times to the right.<p>

<a name="met"></a>
<h2>Methods of Displaying Sprites</h2>
The type of bitmasking used to splice the sprite into the graph buffer has a dramatic effect on the resultant image.<p>

If we use XOR logic to display the sprite, then the black parts will reverse the pixels they intersect with, and the white parts will be transparent. All right, but if two sprites intersect, or the background is highly detailed, the result will look like garbage.<br>
What about OR? In that case the black parts will be black no matter what. This is a nice solution to the problem of intersecting sprites.<br>
What if we have a mostly black background, and we want to display white sprites? Then we can invert the sprite image and use AND. Now the white parts of the sprite will force pixels off, and this time its the black pixels that will be transparent (turnabout is fair play).<p>

<a name="sdr"></a>
<h2>An XOR Sprite Display Routine</h2> 
Okay! here is a very simple SDR that displays XORed sprites.

<pre>
<span class=mem>PutSpriteXOR:</span>
<span class=cmt>; A = x coordinate
; E = y coordinate
; B = number of rows
; IX = address of sprite</span>
    <span class=ins>LD</span>     <span class=reg>H</span>, 0
    <span class=ins>LD</span>     <span class=reg>D</span>, <span class=reg>H</span>
    <span class=ins>LD</span>     <span class=reg>E</span>, <span class=reg>L</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>HL</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>DE</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>HL</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>HL</span>

    <span class=ins>LD</span>     <span class=reg>E</span>, <span class=reg>A</span>
    <span class=ins>SRL</span>    <span class=reg>E</span>
    <span class=ins>SRL</span>    <span class=reg>E</span>
    <span class=ins>SRL</span>    <span class=reg>E</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>DE</span>

    <span class=ins>LD</span>     <span class=reg>DE</span>, <span class=mem>PlotSScreen</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>DE</span>
</pre>

Locate the address the sprite image starts in. This is ripped directly off of <tt>GetPixel</tt>.

<pre>
    <span class=ins>AND</span>    7
    <span class=ins>JR     Z</span>, <span class=mem>_Aligned</span>
</pre>

Modulo <span class=reg>A</span> with 8. We now know both the byte the first row of the sprite is
in, and at which bit in that byte the sprite starts at. If the x coordinate is an exact multiple of eight, then there will be no need for shifting (the sprite is "aligned"). We jump to a part of the routine that specially handles the aligned case for speed.

<pre>
    <span class=ins>LD</span>     <span class=reg>C</span>, <span class=reg>A</span>
    <span class=ins>LD</span>     <span class=reg>DE</span>, 12
</pre>

The bit the sprite starts in is also the shift count, and we need it multiple times so we save it
away. Then 12 is put into <span class=reg>DE</span> so as to move <span class=reg>HL</span> to the next screen row when we are finished with placing a row of the sprite.

<pre>
<span class=mem>_RowLoop:</span>
    <span class=ins>PUSH</span>   <span class=reg>BC</span>
    <span class=ins>LD</span>     <span class=reg>B</span>, <span class=reg>C</span>
    <span class=ins>LD</span>     <span class=reg>C</span>, <span class=reg>(IX)</span>
    <span class=ins>XOR</span>    <span class=reg>A</span>

<span class=mem>_ShiftLoop:</span>
    <span class=ins>SRL</span>    <span class=reg>C</span>
    <span class=ins>RRA</span>
    <span class=ins>DJNZ</span>   <span class=mem>_ShiftLoop</span>
</pre>

Okay, we are going to shift the sprite row across the <span class=reg>A</span> and <span class=reg>C</span> registers until it is in place. A note about the technique: by clearing <span class=reg>A</span> and using <span class=ins>SRL</span>, we guarantee that the empty bits in the two registers hold zeros. This was done to preserve the integrity of the other pixels, since XORing anything with zero causes no change.<br>
At this point, <span class=reg>C</span> contains the left half of the sprite, and <span class=reg>A</span> hold the right.

<pre>
    <span class=ins>INC</span>    <span class=reg>HL</span>
    <span class=ins>XOR</span>    <span class=reg>(HL)</span>
    <span class=ins>LD</span>     <span class=reg>(HL)</span>, <span class=reg>A</span>

    <span class=ins>DEC</span>    <span class=reg>HL</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, <span class=reg>C</span>
    <span class=ins>XOR</span>    <span class=reg>(HL)</span>
    <span class=ins>LD</span>     <span class=reg>(HL)</span>, <span class=reg>A</span>
</pre>

Nothing special, just putting both components of the sprite into the graph buffer.

<pre>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>DE</span>
    <span class=ins>INC</span>    <span class=reg>IX</span>
    <span class=ins>POP</span>    <span class=reg>BC</span>
    <span class=ins>DJNZ</span>   <span class=mem>_RowLoop</span>
    <span class=ins>RET</span>
</pre>

And now we move on to the next line of the sprite and video memory.

<pre>
<span class=mem>_Aligned:</span>
    <span class=ins>LD</span>     <span class=reg>DE</span>, 12

<span class=mem>_PutLoop</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, <span class=reg>(IX)</span>
    <span class=ins>XOR</span>    <span class=reg>(HL)</span>
    <span class=ins>LD</span>     <span class=reg>(HL)</span>, <span class=reg>A</span>
    <span class=ins>INC</span>    <span class=reg>IX</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>DE</span>
    <span class=ins>DJNZ</span>   <span class=mem>_PutLoop</span>
    <span class=ins>RET</span>
</pre>

This is the code to special-case aligned sprites. Looks a lot simpler without all that shifting getting in the way, eh?<p>

<a name="msk"></a>
<h2>Masked Sprites</h2>
What if you want some parts of a sprite to be black, some parts to be white, and other parts to
be transparent? If such sacriliege is to your desire, you can't do it with just the sprite image. There are three attributes to keep track of, but a bit only holds two states, so some of the data
is going to be ambiguous (e.g. for our sample sprite, how could you tell that the corners should be see-through, but the center splotch must be white?). This ambiguity is resolvable, but we require a second image called a mask.<p>

To use a mask with a sprite, use AND logic with the mask to clear a space for the sprite to go, then XOR/OR the sprite data as normal. So, the mask takes care of the white parts, the sprite takes care of the black parts, and the union of the two handles transparency.<p>

By the way, the data for the mask is: 1s for white pixels, 0s for transparent or black pixels.<p>

<h3>A Masked Sprite Display Routine</h3>

<pre>
<span class=mem>PutSpriteMask:</span>
<span class=cmt>; Displays an 8x8 masked sprite
; A = x coordinate
; E = y coordinate
; IX = address of sprite
; IX + 8 = address of mask</span>
    <span class=ins>LD</span>     <span class=reg>H</span>, 0
    <span class=ins>LD</span>     <span class=reg>D</span>, <span class=reg>H</span>
    <span class=ins>LD</span>     <span class=reg>E</span>, <span class=reg>L</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>HL</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>DE</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>HL</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>HL</span>

    <span class=ins>LD</span>     <span class=reg>E</span>, <span class=reg>A</span>
    <span class=ins>SRL</span>    <span class=reg>E</span>
    <span class=ins>SRL</span>    <span class=reg>E</span>
    <span class=ins>SRL</span>    <span class=reg>E</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>DE</span>

    <span class=ins>LD</span>     <span class=reg>DE</span>, <span class=mem>PlotSScreen</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>DE</span>

    <span class=ins>AND</span>    7
    <span class=ins>JR     Z</span>, <span class=mem>_Aligned</span>
    <span class=ins>LD</span>     <span class=reg>C</span>, <span class=reg>A</span>
    <span class=ins>LD</span>     8

<span class=mem>_RowLoop:</span>
    <span class=ins>PUSH</span>   <span class=reg>BC</span>
    <span class=ins>LD</span>     <span class=reg>B</span>, <span class=reg>C</span>
    <span class=ins>LD</span>     <span class=reg>D</span>, <span class=reg>(IX)</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, <span class=reg>(IX + 8)</span>
    <span class=ins>LD</span>     <span class=reg>C</span>, 0
    <span class=ins>LD</span>     <span class=reg>E</span>, <span class=reg>C</span>

<span class=mem>_ShiftLoop:</span>
    <span class=ins>SRL</span>    <span class=reg>A</span>
    <span class=ins>RR</span>     <span class=reg>C</span>
    <span class=ins>SRL</span>    <span class=reg>D</span>
    <span class=ins>RR</span>     <span class=reg>E</span>
    <span class=ins>DJNZ</span>   <span class=mem>_ShiftLoop</span>
</pre>

The code is the same as <tt>PutSpriteXOR</tt> all the way up to <span class=mem>_ShiftLoop</span>. We need to accomodate shifting both a sprite <i>and</i> a mask row. At this point, the sprite is stored in <span class=reg>D:E</span>, and the mask is stored in <span class=mem>A:C</span>

<pre>
    <span class=ins>CPL</span>
    <span class=ins>AND</span>    <span class=reg>(HL)</span>
    <span class=ins>XOR</span>    <span class=reg>D</span>
    <span class=ins>LD</span>     <span class=reg>(HL)</span>, <span class=reg>A</span>

    <span class=ins>INC</span>    <span class=reg>HL</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, <span class=reg>C</span>

    <span class=ins>CPL</span>
    <span class=ins>AND</span>    <span class=reg>(HL)</span>
    <span class=ins>XOR</span>    <span class=reg>E</span>
    <span class=ins>LD</span>     <span class=reg>(HL)</span>, <span class=reg>A</span>
</pre>

The mask data thinks 0-pixels are transparent and 1-pixels are cleared, but AND logic works the other way around, so <span class=ins>CPL</span> is used to invert the mask. You might wonder why not just store the mask the right way, and that's a good point. But then we would have had to have shifted 1's into the mask, and there is no instruction (except for <span class=ins>SLL</span>) that will do that.

<pre>
    <span class=ins>LD</span>     <span class=reg>DE</span>, 12
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>DE</span>
    <span class=ins>INC</span>    <span class=reg>IX</span>
    <span class=ins>POP</span>    <span class=reg>BC</span>
    <span class=ins>DJNZ</span>   <span class=mem>_RowLoop</span>
    <span class=ins>RET</span>

<span class=mem>_Aligned:</span>
    <span class=ins>LD</span>     <span class=reg>DE</span>, 12

<span class=mem>_PutLoop</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, <span class=reg>(IX + 8)</span>
    <span class=ins>AND</span>    <span class=reg>(HL)</span>
    <span class=ins>XOR</span>    <span class=reg>(IX)</span>
    <span class=ins>LD</span>     <span class=reg>(HL)</span>, <span class=reg>A</span>
    <span class=ins>INC</span>    <span class=reg>IX</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>DE</span>
    <span class=ins>DJNZ</span>   <span class=mem>_PutLoop</span>
    <span class=ins>RET</span>
</pre>

I'm not going to bother explaining.<p>

<a name="era"></a>
<h2>Erasing Sprites</h2>
Sprites are meant to be mobile. To be able to move a sprite you have to be able to erase it by restoring the background it obliterated.<p>

XORed sprites, by virtue of the logic of XOR, can be erased merely by being redrawn at the exact same place. But, the OR, AND, and masked sprite types completely destroy the background. There is just no computation you can perform that will bring it back. For these types of sprites, a copy of the background must be made.<p>

<h3>The "Scan-Under" Method</h3>
In the scan-under method, the routine that draws the sprite also takes a snapshot of the area the sprite is going to go on. This snapshot is then displayed like a normal sprite for erasure. Very nice, but for two problems. One, keeping track of the memory involved is a nightmare. Two, you are now displaying each sprite twice. All right for VGA and SVGA graphics modes that represent pixels with whole bytes, this isn't so bad, but the non-alignment contingency inherent in monochrome is murder.<p>

<h3>The "Double-Buffer" Method</h3>
Double buffering is a very simple albeit brutish solution: have two screens buffers: one is the image of what should be displayed on the screen, the other is a backup of the backgroud before the sprites messed it all up. When ready to erase sprites, the backup is copied to the main buffer, erasing every sprite at once! The downside is large memory requirement, and the fact that double-buffer may be slower that scanning at times (16, 000+ clock cycles using <span class=ins>LDIR</span>).<p>

<a name="clp"></a>
<h2>Clipping Sprites</h2>
We have seen two sprite routines already, but they do not account for times when part of the sprite is off the edge of the screen. For cases like these we need to "clip" the sprite so that only the visible part is drawn.<p>

Let's say we have an 8-pixel-by-<i>n</i>-pixel sprite that needs to be clipped. There are six things to look for:
<ul>
<li>If y is negative, then the sprite is off the top edge of the screen and should be clipped.
<li>If x is negative, then the sprite is off the left edge of the screen and should be clipped.
<li>If y is greater than 64-<i>n</i>, then the sprite is off the bottom edge of the screen and should be clipped.
<li>If x is greater than 88 (96-8), then the sprite is off the right edge of the screen and should be clipped.
<li>If y is -<i>n</i> or greater, or greater than 63, or if x is less than -7 or greater than 95, the sprite is entirely off the screen and shouldn't be displayed at all.
<li>If none of the above cases are true, then the sprite is fully on the screen and should be drawn without clipping.
</ul>

<h3>Vertical Clipping</h3>
Let's look at code to see how to clip the top and bottom of a sprite. It's quite easy, so let's just jump right in.

<pre>
<span class=cmt>; E = y-position
; B = rows
; HL = address of sprite</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, <span class=reg>E</span>
    <span class=ins>OR</span>     <span class=reg>A</span>
    <span class=ins>JP     M</span>, <span class=mem>ClipTop</span>
</pre>
Is y negative? If so, then we should clip the top part. Back to this in a minute, now let's do bottom clipping

<pre>
    <span class=ins>SUB</span>    64
    <span class=ins>RET    NC</span>
</pre>
Is y >= 64? If so, the sprite is off-screen and so we should stop.

<pre>
    <span class=ins>NEG</span>
    <span class=ins>CP</span>     <span class=reg>B</span>
    <span class=ins>JR     NC</span>, <span class=mem>VertClipDone</span>
</pre>
Doing -(<span class=reg>A</span> - 64) is the same as doing 64 - <span class=reg>A</span>, and gives the number of sprite rows that will be visible. If this number is >= the number of rows in the sprite, then clipping isn't necessary.

<pre>
    <span class=ins>LD</span>     <span class=reg>B</span>, <span class=reg>A</span>
    <span class=ins>JR</span>     <span class=mem>VertClipDone</span>
</pre>
Clipping the bottom is done by shrinking the height of the sprite so that only the topmost rows are displayed.

<pre>
<span class=mem>ClipTop:</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, <span class=reg>B</span>
    <span class=ins>NEG</span>
    <span class=ins>SUB</span>    <span class=reg>E</span>
    <span class=ins>RET    NC</span>
</pre>
Is y <= -height? If so, the sprite is off the screen and so don't display it.<p>

Now at this point we know we must clip the sprite at the top, and to do so we must do three things:
<ul>
<li>Set the y-coordinate to 0.
<li>Decrease the height by the number of rows that will be clipped.
<li>Increase the pointer to the sprite image by the number of rows that will be clipped.
</ul>
We can get the number of rows that are clipped by adding the height to <span class=reg>A</span>, as you can see from this table that summarizes the results of the last calculation (assuming the sprite is eight rows tall):<p>
y = -1: <span class=reg>A</span> = (256-8) - (256-1) = 248 - 255 = -7<br>
y = -2: <span class=reg>A</span> = (256-8) - (256-2) = 248 - 254 = -6<br>
y = -3: <span class=reg>A</span> = (256-8) - (256-3) = 248 - 253 = -5<br>
y = -4: <span class=reg>A</span> = (256-8) - (256-4) = 248 - 252 = -4<br>
y = -5: <span class=reg>A</span> = (256-8) - (256-5) = 248 - 251 = -3<br>
y = -6: <span class=reg>A</span> = (256-8) - (256-6) = 248 - 250 = -2<br>
y = -7: <span class=reg>A</span> = (256-8) - (256-7) = 248 - 249 = -1<br>

<pre>
    <span class=ins>PUSH</span>   <span class=reg>AF</span>
    <span class=ins>ADD</span>    <span class=reg>A</span>, <span class=reg>B</span>
    <span class=ins>LD</span>     <span class=reg>E</span>, 0
    <span class=ins>LD</span>     <span class=reg>B</span>, <span class=reg>E</span>
    <span class=ins>LD</span>     <span class=reg>C</span>, <span class=reg>A</span>
    <span class=ins>ADD</span>    <span class=reg>IX</span>, <span class=reg>BC</span>
    <span class=ins>POP</span>    <span class=reg>AF</span>              <span class=cmt>; Get the new height</span>
    <span class=ins>NEG</span>
    <span class=ins>LD</span>     <span class=reg>B</span>, <span class=reg>A</span>

<span class=mem>VertClipDone:</span>
<span class=cmt>; Display the sprite here.</span>
</pre>

<h3>Horizontal Clipping</h3>
Horizontal clipping can be done in a manner similar to vertical clipping. Assume the sprite is eight pixels wide. Let's start  with the sprite being off the right edge of the screen. If it's position is greater than 95, it won't be visible. But if it's between 89 and 95 inclusive we have to do some clipping. We can do this with a cheap little trick.<br>
Assume that we want to display the sprite at (91, 15). Now supposing we tried to display the sprite at that position without any clipping, the left side would look all right, but the right side would appear on the left edge of the screen, shifted down one pixel. The key to properly clipping the sprite is to wipe out those pixels that are going to wrap. We can do this with an AND bitmask each time a sprite row is going to be displayed (prior to it being shifted into position). The bitmask used is from this table:<p>

x = 89: 1 bits of the sprite will wrap; bitmask with %11111110<br>
x = 90: 2 bits of the sprite will wrap; bitmask with %11111100<br>
x = 91: 3 bits of the sprite will wrap; bitmask with %11111000<br>
x = 92: 4 bits of the sprite will wrap; bitmask with %11110000<br>
x = 93: 5 bits of the sprite will wrap; bitmask with %11100000<br>
x = 94: 6 bits of the sprite will wrap; bitmask with %11000000<br>
x = 95: 7 bits of the sprite will wrap; bitmask with %10000000<p>

To figure out the bitmask, all we need to do for coding is
<pre>
<span class=cmt>; Given that A is the x-coordinate</span>
    <span class=ins>AND</span>    7
    <span class=ins>LD</span>     <span class=reg>B</span>, <span class=reg>A</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, %11111111
<span class=mem>_CalcMask:</span>
    <span class=ins>ADD</span>    <span class=reg>A</span>, <span class=reg>A</span>
    <span class=ins>DJNZ</span>   <span class=mem>_CalcMask</span>
    <span class=ins>LD</span>     <span class=mem>(clip_mask)</span>, <span class=reg>A</span>
</pre><p>

For clipping on the left edge, we can again exploit the wraparound effect. If a negative x-coordinate is increased so that it is very close to the right edge of the screen, part will spill over, and the portion that should be clipped is displayed normally. The magic number to be added is 96, and the bitmask is found exactly the same way as was done for right clipping (the only difference, the mask must be inverted).<p>

<pre>
<span class=cmt>; Given that A is the x-coordinate, and E is the y-coordinate</span>
    <span class=ins>PUSH</span>   <span class=reg>AF</span>
    <span class=ins>AND</span>    7
    <span class=ins>LD</span>     <span class=reg>B</span>, <span class=reg>A</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, %11111111
<span class=mem>_CalcMask:</span>
    <span class=ins>ADD</span>    <span class=reg>A</span>, <span class=reg>A</span>
    <span class=ins>DJNZ</span>   <span class=mem>_CalcMask</span>
    <span class=ins>CPL</span>
    <span class=ins>LD</span>     <span class=mem>(clip_mask)</span>, <span class=reg>A</span>
    <span class=ins>POP</span>    <span class=reg>AF</span>
    <span class=ins>ADD</span>    <span class=reg>A</span>, 96
    <span class=ins>DEC</span>    <span class=reg>E</span>
</pre><p>

<a name="csx"></a>
<h2>Clipped XOR Sprite Display Routine</h2>
Now it's time for some fun. Here is an XOR sprite routine with full clipping, and wrapped up in a program to boot (it's big, but all you really care about is the actual routine). The core of the SDR has changed only slightly to accomodate horizontal clipping.<p>

<h3>Program 25-1</h3>
<div class=Program>
<pre>
        b_call(_RunIndicOff)
        b_call(_GrBufClr)

<span class=mem>Show:</span>
        <span class=ins>CALL</span>    <span class=mem>PutSpr</span>
        b_call(_GrBufCpy)

<span class=mem>KeyLoop:</span>
        b_call(_GetKey)
        <span class=ins>CP</span>      <span class=mem>kClear</span>
        <span class=ins>RET     Z</span>

        <span class=ins>CP</span>      <span class=mem>kUp</span>
        <span class=ins>JR      Z</span>, <span class=mem>MoveUp</span>
        <span class=ins>CP</span>      <span class=mem>kDown</span>
        <span class=ins>JR      Z</span>, <span class=mem>MoveDown</span>
        <span class=ins>CP</span>      <span class=mem>kLeft</span>
        <span class=ins>JR      Z</span>, <span class=mem>MoveLeft</span>
        <span class=ins>CP</span>      <span class=mem>kRight</span>
        <span class=ins>JR      NZ</span>, <span class=mem>KeyLoop</span>

<span class=cmt>; Move sprite right</span>
        <span class=ins>CALL</span>    <span class=mem>PutSpr</span>          <span class=cmt>; Erase sprite</span>
        <span class=ins>LD</span>      <span class=reg>HL</span>, <span class=mem>xpos</span>
        <span class=ins>INC</span>     <span class=reg>(HL)</span>
        <span class=ins>JR</span>      <span class=mem>Show</span>            <span class=cmt>; Draw sprite at new location</span>

<span class=mem>MoveLeft:</span>
<span class=cmt>; Move sprite left</span>
        <span class=ins>CALL</span>    <span class=mem>PutSpr</span>
        <span class=ins>LD</span>      <span class=reg>HL</span>, <span class=mem>xpos</span>
        <span class=ins>DEC</span>     <span class=reg>(HL)</span>
        <span class=ins>JR</span>      <span class=mem>Show</span>

<span class=mem>MoveUp:</span>
<span class=cmt>; Move sprite up</span>
        <span class=ins>CALL</span>    <span class=mem>PutSpr</span>
        <span class=ins>LD</span>      <span class=reg>HL</span>, <span class=mem>ypos</span>
        <span class=ins>DEC</span>     <span class=reg>(HL)</span>
        <span class=ins>JR</span>      <span class=mem>Show</span>

<span class=mem>MoveDown:</span>
        <span class=ins>CALL</span>    <span class=mem>PutSpr</span>
        <span class=ins>LD</span>      <span class=reg>HL</span>, <span class=mem>ypos</span>
        <span class=ins>INC</span>     <span class=reg>(HL)</span>
        <span class=ins>JR</span>      <span class=mem>Show</span>

<span class=mem>ypos:</span>   <span class=dir>.DB</span>     0
<span class=mem>xpos:</span>   <span class=dir>.DB</span>     0

<span class=mem>sprite:</span>
        <span class=dir>.DB</span>     %10000001
        <span class=dir>.DB</span>     %11000011
        <span class=dir>.DB</span>     %01100110
        <span class=dir>.DB</span>     %00111100
        <span class=dir>.DB</span>     %00111100
        <span class=dir>.DB</span>     %01100110
        <span class=dir>.DB</span>     %11000011
        <span class=dir>.DB</span>     %10000001

<span class=mem>PutSpr:</span>
        <span class=ins>LD</span>      <span class=reg>DE</span>, <span class=mem>(ypos)</span>
        <span class=ins>LD</span>      <span class=reg>IX</span>, <span class=mem>sprite</span>
        <span class=ins>LD</span>      <span class=reg>B</span>, 8

<span class=mem>ClipSprXOR:</span>
<span class=cmt>; D = xpos
; E = ypos
; B = height
; IX = image address
; Start by doing vertical clipping</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, %11111111         <span class=cmt>; Reset clipping mask</span>
    <span class=ins>LD</span>     <span class=mem>(clip_mask)</span>, <span class=reg>A</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, <span class=reg>E</span>                 <span class=cmt>; If ypos is negative</span>
    <span class=ins>OR</span>     <span class=reg>A</span>                    <span class=cmt>; try clipping the top</span>
    <span class=ins>JP     M</span>, <span class=mem>ClipTop</span>           <span class=cmt>;</span>
 
    <span class=ins>SUB</span>    64                   <span class=cmt>; If ypos is >= 64</span>
    <span class=ins>RET    NC</span>                   <span class=cmt>; sprite is off-screen</span>

    <span class=ins>NEG</span>                         <span class=cmt>; If (64 - ypos) > height</span>
    <span class=ins>CP</span>     <span class=reg>B</span>                    <span class=cmt>; don't need to clip</span>
    <span class=ins>JR     NC</span>, <span class=mem>VertClipDone</span>     <span class=cmt>;</span> 

    <span class=ins>LD</span>     <span class=reg>B</span>, <span class=reg>A</span>                 <span class=cmt>; Do bottom clipping by</span>
    <span class=ins>JR</span>     <span class=mem>VertClipDone</span>         <span class=cmt>; setting height to (64 - ypos)</span>

<span class=mem>ClipTop:</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, <span class=reg>B</span>                 <span class=cmt>; If ypos <= -height</span>
    <span class=ins>NEG</span>                         <span class=cmt>; sprite is off-screen</span>
    <span class=ins>SUB</span>    <span class=reg>E</span>                    <span class=cmt>;</span>
    <span class=ins>RET    NC</span>                   <span class=cmt>;</span>

    <span class=ins>PUSH</span>   <span class=reg>AF</span>
    <span class=ins>ADD</span>    <span class=reg>A</span>, <span class=reg>B</span>                 <span class=cmt>; Get the number of clipped rows</span>
    <span class=ins>LD</span>     <span class=reg>E</span>, 0                 <span class=cmt>; Set ypos to 0 (top of screen)</span>
    <span class=ins>LD</span>     <span class=reg>B</span>, <span class=reg>E</span>                 <span class=cmt>; Advance image data pointer</span>
    <span class=ins>LD</span>     <span class=reg>C</span>, <span class=reg>A</span>                 <span class=cmt>;</span>
    <span class=ins>ADD</span>    <span class=reg>IX</span>, <span class=reg>BC</span>               <span class=cmt>;</span>
    <span class=ins>POP</span>    <span class=reg>AF</span>
    <span class=ins>NEG</span>                         <span class=cmt>; Get the number of visible rows</span>
    <span class=ins>LD</span>     <span class=reg>B</span>, <span class=reg>A</span>                 <span class=cmt>; and set as height</span>

<span class=mem>VertClipDone:</span>
<span class=cmt>; Now we're doing horizontal clipping</span>
    <span class=ins>LD</span>     <span class=reg>C</span>, 0                 <span class=cmt>; Reset correction factor</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, <span class=reg>D</span>

    <span class=ins>CP</span>     -7                   <span class=cmt>; If 0 > xpos >= -7</span>
    <span class=ins>JR     NC</span>, <span class=mem>ClipLeft</span>         <span class=cmt>; clip the left side</span>

    <span class=ins>CP</span>     96                   <span class=cmt>; If xpos >= 96</span>
    <span class=ins>RET    NC</span>                   <span class=cmt>; sprite is off-screen</span>

    <span class=ins>CP</span>     89                   <span class=cmt>; If 0 <= xpos < 89</span>
    <span class=ins>JR     C</span>, <span class=mem>HorizClipDone</span>     <span class=cmt>; don't need to clip</span>

<span class=mem>ClipRight:</span>
    <span class=ins>AND</span>    7                    <span class=cmt>; Determine the clipping mask</span>
    <span class=ins>LD</span>     <span class=reg>C</span>, <span class=reg>A</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, %11111111
<span class=mem>FindRightMask:</span>
    <span class=ins>ADD</span>    <span class=reg>A</span>, <span class=reg>A</span>
    <span class=ins>DEC</span>    <span class=reg>C</span>
    <span class=ins>JR     NZ</span>, <span class=mem>FindRightMask</span>
    <span class=ins>LD</span>     <span class=mem>(clip_mask)</span>, <span class=reg>A</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, <span class=reg>D</span>
    <span class=ins>JR</span>     <span class=mem>HorizClipDone</span>

<span class=mem>ClipLeft:</span>
    <span class=ins>AND</span>    7                    <span class=cmt>; Determine the clipping mask</span>
    <span class=ins>LD</span>     <span class=reg>C</span>, <span class=reg>A</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, %11111111
<span class=mem>FindLeftMask:</span>
    <span class=ins>ADD</span>    <span class=reg>A</span>, <span class=reg>A</span>
    <span class=ins>DEC</span>    <span class=reg>C</span>
    <span class=ins>JR     NZ</span>, <span class=mem>FindLeftMask</span>
    <span class=ins>CPL</span>
    <span class=ins>LD</span>     <span class=mem>(clip_mask)</span>, <span class=reg>A</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, <span class=reg>D</span>
    <span class=ins>ADD</span>    <span class=reg>A</span>, 96                <span class=cmt>; Set xpos so sprite will "spill over"</span>
    <span class=ins>LD</span>     <span class=reg>C</span>, 12                <span class=cmt>; Set correction</span>

<span class=mem>HorizClipDone:</span>
<span class=cmt>; A = xpos
; E = ypos
; B = height
; IX = image address

; Now we can finally display the sprite.</span>
    <span class=ins>LD</span>     <span class=reg>H</span>, 0
    <span class=ins>LD</span>     <span class=reg>D</span>, <span class=reg>H</span>
    <span class=ins>LD</span>     <span class=reg>L</span>, <span class=reg>E</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>HL</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>DE</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>HL</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>HL</span>

    <span class=ins>LD</span>     <span class=reg>E</span>, <span class=reg>A</span>
    <span class=ins>SRL</span>    <span class=reg>E</span>
    <span class=ins>SRL</span>    <span class=reg>E</span>
    <span class=ins>SRL</span>    <span class=reg>E</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>DE</span>

    <span class=ins>LD</span>     <span class=reg>DE</span>, <span class=mem>PlotSScreen</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>DE</span>

    <span class=ins>LD</span>     <span class=reg>D</span>, 0                 <span class=cmt>; Correct graph buffer address</span>
    <span class=ins>LD</span>     <span class=reg>E</span>, <span class=reg>C</span>                 <span class=cmt>; if clipping the left side</span>
    <span class=ins>SBC</span>    <span class=reg>HL</span>, <span class=reg>DE</span>               <span class=cmt>;</span>

    <span class=ins>AND</span>    7
    <span class=ins>JR     Z</span>, <span class=mem>_Aligned</span>

    <span class=ins>LD</span>     <span class=reg>C</span>, <span class=reg>A</span>
    <span class=ins>LD</span>     <span class=reg>DE</span>, 11

<span class=mem>_RowLoop:</span>
    <span class=ins>PUSH</span>   <span class=reg>BC</span>
    <span class=ins>LD</span>     <span class=reg>B</span>, <span class=reg>C</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, <span class=mem>(clip_mask)</span>       <span class=cmt>; Mask out the part of the sprite</span>
    <span class=ins>AND</span>    <span class=reg>(IX)</span>                 <span class=cmt>; to be horizontally clipped</span>
    <span class=ins>LD</span>     <span class=reg>C</span>, 0

<span class=mem>_ShiftLoop:</span>
    <span class=ins>SRL</span>    <span class=reg>A</span>
    <span class=ins>RR</span>     <span class=reg>C</span>
    <span class=ins>DJNZ</span>   <span class=mem>_ShiftLoop</span>

    <span class=ins>XOR</span>    <span class=reg>(HL)</span>
    <span class=ins>LD</span>     <span class=reg>(HL)</span>, <span class=reg>A</span>

    <span class=ins>INC</span>    <span class=reg>HL</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, <span class=reg>C</span>
    <span class=ins>XOR</span>    <span class=reg>(HL)</span>
    <span class=ins>LD</span>     <span class=reg>(HL)</span>, <span class=reg>A</span>

    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>DE</span>
    <span class=ins>INC</span>    <span class=reg>IX</span>
    <span class=ins>POP</span>    <span class=reg>BC</span>
    <span class=ins>DJNZ</span>   <span class=mem>_RowLoop</span>
    <span class=ins>RET</span>

<span class=mem>_Aligned:</span>
    <span class=ins>LD</span>     <span class=reg>DE</span>, 12

<span class=mem>_PutLoop:</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, <span class=reg>(IX)</span>
    <span class=ins>XOR</span>    <span class=reg>(HL)</span>
    <span class=ins>LD</span>     <span class=reg>(HL)</span>, <span class=reg>A</span>
    <span class=ins>INC</span>    <span class=reg>IX</span>
    <span class=ins>ADD</span>    <span class=reg>HL</span>, <span class=reg>DE</span>
    <span class=ins>DJNZ</span>   <span class=mem>_PutLoop</span>
    <span class=ins>RET</span>

<span class=mem>clip_mask:</span>      <span class=dir>.DB</span>     0
</pre>
</div>


<hr>
<div class=NavFooter>
    <a href="day24.html">PREVIOUS - Day 24: Monochrome Graphics</a><p>
    <a href="day26.html">NEXT - Day 26: The LCD Driver</a><p>
    <a href="toc.html">Table Of Contents</a>
</div>
    <hr>
<address>
This is part of Learn TI-83 Plus Assembly In 28 Days<br>
Copyright (c) 2002, 2003, 2004 Sean McLaughlin<br>
See the file gfdl.html for copying conditions
</address>
<hr>
</body>
</html>