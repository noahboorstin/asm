<html>
<head>
<title>Learn TI-83 Plus Assembly In 28 Days &mdash; Day 23 &mdash; Interrupts</title>
<link rel="Stylesheet" href="../stuff/format.css">
</head>

<body>

<div class=NavHeader>
    &middot; <a href="toc.html">Table Of Contents</a>
    &middot; <a href="day22.html">Previous</a>
    &middot; <a href="day24.html">Next</a>
    &middot;
</div>

    <hr>
    <h1>DAY 23. Interrupts</h1>
    <hr>
    <b><font color=#CCCCCC>novice intermediate advanced <font color=#CC0000>expert</font></font></b><hr>

<ul class=TopicList>
<li type="disc"><a href="#swi">Software Interrupts</a>
<li type="square"><a href="#hwi">Hardware Interrupts</a>
<li type="disc"><a href="#set">Interrupt Setup</a>
<li type="disc"><a href="#mnt">Interrupt Maintenance</a>
<li type="disc"><a href="#det">Interrupt Detection</a>
<li type="disc"><a href="#por">Interrupt Ports</a>
<li type="circle"><a href="#tsr">TSRs</a>
</ul>
    <hr>

An interrupt is a break in the normal flow in a program that can be returned to. Speaking generally, all calls
(but not jumps) are interrupts. When an interrupt is initiated, control immediately passes to an Interrupt Service
Routine which does what it needs to, then returns to the point of interruption.<p>

<a name=swi></a>
    <h2>Software Interrupts</h2>
    A software interrupt is intentionally generated by the programmer.
    A <span class=ins>CALL</span> instruction is technically a software interrupt, but we will
    reserve the term for restarts. A restart is identical to <span class=ins>CALL</span> but it
    takes only one byte. The are used for different things on different platforms, but on all the
    TI calculators they execute common OS routines.<p>

<table class=Command>
<tr>
    <td class=CmdSyntax>
    <tt><b>RST</b> <i>xx</i></tt></td>
    <td>Software restart to address <tt>$00<i>xx</i></tt>. See table for valid values for
    <tt><i>xx</i><tt></td>
</tr>
</table><p>

<table class=Normal>
<tr class=Heading>
    <th>Argument</th>
    <th>Result</th>
</tr>
<tr>
    <td class=SubHeading>00h</td>
    <td>Simulates taking all the batteries out of the calculator.</td>
</tr>
<tr>
    <td class=SubHeading>08h</td>
    <td>Execute system routine <tt>OP1ToOP2</tt>.</td>
</tr>
<tr>
    <td class=SubHeading>10h</td>
    <td>Execute system routine <tt>FindSym</tt>.</td>
</tr>
<tr>
    <td class=SubHeading>18h</td>
    <td>Execute system routine <tt>PushRealO1</tt>.</td>
</tr>
<tr>
    <td class=SubHeading>20h</td>
    <td>Execute system routine <tt>Mov9ToOP1</tt>.</td>
</tr>
<tr>
    <td class=SubHeading>28h</td>
    <td>Part of the <tt>b_call()</tt> macro.</td>
</tr>
<tr>
    <td class=SubHeading>30h</td>
    <td>Execute system routine <tt>FPAdd</tt>.</td>
</tr>
<tr>
    <td class=SubHeading>38h</td>
    <td>System interrupt routine.</td>
</tr>
</table><p>

    The <span class=ins>RST</span> commands are two bytes smaller than the corresponding
    <tt>b_call()</tt> command, and are also a lot faster, so use them whenever possible. And
    yes, the arguments to <span class=ins>RST</span> have to be hex numbers in -<tt>h</tt>
    form.<p>

<a name="hwi"></a>
    <h2>Hardware Interrupts</h2>

Hardware interrupts are based on some external event that has nothing to do with the instructions
the CPU is executing.<p>

Software or hardware, all interrupts when triggered are like normal <span class=ins>CALL</span>s, in that
the current <span class=reg>PC</span> value is pushed onto the stack and there is a transfer to wherever
the ISR is located. The actual address depends on the current interrupt mode.<p>

<table class=Command>
<tr>
    <td class=CmdSyntax><tt><b>IM</b> <i>x</i></tt></td>
    <td>Sets interrupt mode <tt><i>x</i></tt>. <tt><i>x</i></tt> = 0, 1, or 2</td>
</tr>
</table><p>

    <h3>Mode 0</h3>
In mode 0, only external hardware peripherals can generate interrupts. The ISR is a single byte sent by
the peripheral that the CPU executes as an opcode. The calculator cannot use mode 0.<p>

    <h3>Mode 1</h3>
At a frequency of about 140Hz or less, the CPU executes a <span class=ins>RST </span><tt>28H</tt> instruction. The TI-83
Plus uses this interrupt to detect keys, blink the cursor, check the linkport, etc.<p>

The system interrupt uses <span class=reg>SP</span> (naturally) and <span class=reg>IY</span>, so if you want to use these
registers for other purposes you need to disable interrupts (or just not process the system interrupt).<p>

    <h3>Mode 2</h3>
The most fun. In mode 2, the CPU can theoretically jump to any address in memory. This is the interrupt mode
we are interested in.<p>

<a name="set"></a>
    <h2>Setting Up a Mode 2 ISR</h2>
In Mode 2, the CPU gets the interrupt address using the <span class=reg>I</span> register. You'd figure <span class=reg>I</span> would be a 16-bit register to hold the address of the interrupt, but that would be too easy.
Instead, <span class=reg>I</span> holds bits 15 to 8 of a pointer to a vector table where the interrupt's real address is
stored. (Note: you can only load into/from <span class=reg>I</span> using <span class=reg>A</span>). Bits 7 to 1
of this address is a number taken from the data bus and is functionally random. Since addresses are 16 bits the
pointer <i>must</i> be an even number, and for this reason bit 0 is always zero<p>

This is the official ZiLog description of a Mode 2 interrupt, on the TI calculators something is awry and interrupt behavior is contradictory to what was described above. With a lot of experimentation (and a lot of RAM clears), I have discovered that the value of the
interrupt vector is made up as follows:<p>

<ul>
<li>The upper 8 bits are taken from the contents of the <span class=reg>I</span> register.
<li>The next two bits seem to be random.
<li>The last six bits are always %111111.
</ul>

In the past, programmers who wanted to use an interrupt just assumed the low-order byte of the interrupt vector was random
and had to set up a 257-byte table made up of the same byte value over and over. As a result, the largest scrap RAM area
would be untouchable for variable storage.<p>

The vector table is initialized with code similar to the following:<p>

<pre>
<span class=cmt>; Assume an ISR located at $9DF0</span>
    <span class=ins>LD</span>    <span class=reg>HL</span>, $9DF0

    <span class=ins>LD</span>    ($993F), <span class=reg>HL</span>
    <span class=ins>LD</span>    ($997F), <span class=reg>HL</span>
    <span class=ins>LD</span>    ($99BF), <span class=reg>HL</span>
    <span class=ins>LD</span>    ($99FF), <span class=reg>HL</span>
</pre>

N.B. All the vectors are stored in <span class=mem>AppBackupScreen</span> RAM area.<p>

Now we should create the ISR. When an ISR begins, it has to save the values of all the registers it will modify. The
reason for this is simple: if it didn't, then the values of the registers would be changed 140 times a second to something unknown, which would play havoc with the normal program. This can be done either with the stack or very quickly with two instructions.<p>

<table class=Command>
<tr>
    <td class=CmdSyntax>
    <tt><b>EX</b> AF, AF'</tt></td>
    <td>Exchange register pair <tt>AF</tt> with alternate register pair
    <tt>AF'</tt>.</td>
</tr>
</table><p>

<table class=Command>
<tr>
    <td class=CmdSyntax><tt><b>EXX</b></tt></td>
    <td>Exchange register pairs <tt>BC</tt>, <tt>DE</tt>, and
    <tt>HL</tt> with alternate register pairs <tt>BC'</tt>, <tt>DE'</tt>, and <tt>HL'</tt>.</td>
</tr>
</table><p>

<a name="mnt"></a>
    <h2>Interrupt Maintenance</h2>
<table class=Command>
<tr>
    <td class=CmdSyntax>
    <tt><b>DI</b></tt></td>
    <td>Disable interrupts</td>
</tr>
</table><p>

<table class=Command>
<tr>
    <td class=CmdSyntax>
    <tt><b>EI</b></tt></td>
    <td>Enable interrupts</td>
</tr>
</table><p>

<table class=Command>
<tr>
    <td class=CmdSyntax>
    <tt><b>HALT</b></tt></td>
    <td>Stop execution and enter low-power mode. On next interrupt, "wake up" and resume execution.</td>
</tr>
</table><p>

If a <span class=ins>HALT</span> is executed, the LSB of the next interrupt vector will always be %11111111.<p>

You should have interrupts disabled while you are loading the interrupt data. Some cretin might have left the CPU in Mode 2
when you exited his game. If an interrupt triggers while you are overwriting pre-existing interrupt code, you're definitely
gonna be feeling below average.<p>

Interrupts should be short and execute quickly (rendering a raytraced 3D scene in an interrupt is definitely not on :-). If
an interrupt takes too long to complete it may very well be re-initiated and loop forever. To make sure this doesn't happen, 
you must know the interrupt enable port (#3).<p>

<table class=info>
<tr>
 <th class=Heading>Bit</th>
 <th class=Heading>If Set</th>
 <th class=Heading>If Reset</th>
</tr>
<tr>
 <th class=SubHeading>0</th>
 <td><tt>[ON]</tt> key interrupts are serviced</td>
 <td><tt>[ON]</tt> key interrupts are ignored</td>
</tr>
<tr>
 <th class=SubHeading>1</th>
 <td>Timer interrupts are serviced</td>
 <td>Timer interrupts are ignored</td>
</tr>
<tr>
 <th class=SubHeading>4</th>
 <td>Linkport interrupts are serviced</td>
 <td>Linkport interrupts are ignored</td>
</tr>
</table><p>

The meanings of bits 2 and 3 are not known. When the interrupt is entered, output %00000000 to disable all interrupts and
prevent an infinite loop. To return, output %00001101, restore the registers, re-enable interrupts, and then finally
return.<p>

<a name="det"></a>
    <h2>Detecting Interrupts</h2>
You might want to know if interrupts are currently active or not. I can't think of a use for this, but...<br>
On the Z80 CPU, there are two devices (flip-flops) that are called <tt>IFF1</tt> and <tt>IFF2</tt>. When the interrupt timer
goes off, <tt>IFF1</tt> is checked to see if the interrupt can run. <tt>IFF2</tt> is used to save the status of
<tt>IFF1</tt>.<p>

To check the status of the flip-flops, a <tt><span class=ins>LD</span> <span class=reg>A</span>, <span class=reg>I</span></tt> 
or <tt><span class=ins>LD</span> <span class=reg>A</span>, <span class=reg>R</span></tt> instruction will store the status
of <tt>IFF2</tt> in the <span class=ins>P/V</span> flag. Reset means interrupts are disabled, set means interrupts are active.<p>

    <h3>Program 23-1</h3>
    Here's a sample program that demonstrates everything so far.

<div class=Program>
<pre>
<span class=mem>INTRPT_MASK</span>   <span class=dir>.EQU</span>   %00001011

    b_call(_ClrLCDFull)

    <span class=ins>DI</span>                     <span class=cmt>; Turn interrupts off until we're ready</span>

<span class=cmt>; Load interrupt address vectors</span>
    <span class=ins>LD</span>     <span class=reg>HL</span>, <span class=mem>interrupt</span>
    <span class=ins>LD</span>     ($993F), <span class=reg>HL</span>
    <span class=ins>LD</span>     ($997F), <span class=reg>HL</span>
    <span class=ins>LD</span>     ($99BF), <span class=reg>HL</span>
    <span class=ins>LD</span>     ($99FF), <span class=reg>HL</span>

    <span class=ins>LD</span>     <span class=reg>A</span>, $99
    <span class=ins>LD</span>     <span class=reg>I</span>, <span class=reg>A</span>

    <span class=ins>LD</span>     <span class=reg>A</span>, <span class=mem>INTRPT_MASK</span>   <span class=cmt>; Enable hardware</span>
    <span class=ins>OUT</span>    (3), <span class=reg>A</span>

    <span class=ins>IM</span>     2               <span class=cmt>; Switch to Mode 2</span>
    <span class=ins>EI</span>                     <span class=cmt>; Activate interrupts</span>

<span class=cmt>; GetKey and GetCSC only function in Mode 1, 
; so gotta use the key port.</span>
    <span class=ins>LD</span>     <span class=reg>A</span>, %10111111
    <span class=ins>OUT</span>    (1), <span class=reg>A</span>

<span class=mem>KeyLoop:</span>
    <span class=ins>IN</span>     <span class=reg>A</span>, (1)
    <span class=ins>CP</span>     %01111111       <span class=cmt>; If [DEL] pressed, exit</span>
    <span class=ins>JR     NZ</span>, <span class=mem>KeyLoop</span>

    <span class=ins>LD</span>     <span class=reg>A</span>, %00001011     <span class=cmt>; Enable hardware</span>
    <span class=ins>OUT</span>    (3), <span class=reg>A</span>
    <span class=ins>IM</span>     1               <span class=cmt>; Calculator needs Mode 1</span>
    <span class=ins>RET</span>

<span class=mem>interrupt:</span>
    <span class=ins>EX</span>     <span class=reg>AF</span>, <span class=reg>AF'</span>
    <span class=ins>EXX</span>
    <span class=ins>XOR</span>     <span class=reg>A</span>              <span class=cmt>; Disable hardware</span>
    <span class=ins>OUT</span>    (3), <span class=reg>A</span>

    <span class=ins>LD</span>     <span class=reg>HL</span>, 0
    <span class=ins>LD</span>     <span class=mem>(CurRow)</span>, <span class=reg>HL</span>
    <span class=ins>LD</span>     <span class=reg>HL</span>, <span class=mem>(counter)</span>
    <span class=ins>INC</span>    <span class=reg>HL</span>
    <span class=ins>LD</span>     <span class=mem>(counter)</span>, <span class=reg>HL</span>
    b_call(_DispHL)

    <span class=ins>LD</span>     <span class=reg>A</span>, <span class=mem>INTRPT_MASK</span>   <span class=cmt>; Enable hardware</span>
    <span class=ins>OUT</span>    (3), <span class=reg>A</span>
    <span class=ins>EX</span>     <span class=reg>AF</span>, <span class=reg>AF'</span>
    <span class=ins>EXX</span>
    <span class=ins>EI</span>
    <span class=ins>RET</span>

<span class=mem>counter:</span>
    <span class=dir>.DW</span>    $0000
</pre>
</div>

The program counts at a frenetic pace until you press [DEL]. For more fun, change the value of <span
class=mem>INTRPT_MASK</span> to disable certain hardware events.<p>

<a name="por"></a>
    <h2>Interrupt Ports</h2>
    You already know port 3, here's another<p>

    <h3>Port 4 &mdash; Interrupt Status Port</h3>
<table class=info>
<tr>
 <th class=Transparent colspan=3>Inputs</th>
</tr>
<tr>
 <th class=Heading>Bit</th>
 <th class=Heading>If Set</th>
 <th class=Heading>If Reset</th>
</tr>
<tr>
 <th class=SubHeading>0</th>
 <td>[ON] key interrupt has been generated</td>
 <td>[ON] key interrupt has not been generated</td>
</tr>
<tr>
 <th class=SubHeading>1</th>
 <td>Timer interrupt has been generated</td>
 <td>Timer interrupt has not been generated</td>
</tr>
<tr>
 <th class=SubHeading>3</th>
 <td>[ON] key is being depressed</td>
 <td>[ON] key is up</td>
</tr>
<tr>
 <th class=Transparent colspan=3>Outputs</th>
</tr>
<tr>
 <th class=SubHeading>0</th>
 <td colspan=2>Force [ON] interrupt status</td>
</tr>
<tr>
 <th class=SubHeading>1-2</th>
 <td colspan=2>Interrupt speed (0 to 3). %11 is slowest, %00 is fastest. Normal speed is %11</td>
</tr>
</table><p>

The TI-OS has the system flag <span class=mem>OnInterrupt</span> that is set if a one is read from bit 0 of port
4. This will result in an <tt>ERR: BREAK</tt> message when the program returns to the home screen. You can prevent this by <ul>
<li>Disabling the ON interrupt.
<li>Clearing the ON status flag.
<li>Resetting the system flag.
<li>The flag is only set in the system interrupt, so just don't run it.
</ul><p>

<a name="tsr"></a>
    <h2>TSRs</h2>
TSRs are Terminate and Stay Resident programs. If you change the <span class=ins>RET</span> and exchange instructions in
your interrupt to <tt><span class=ins>JP</span> $003A</tt>, then you'll process the calculator's system interrupt as
well as your own.<p>

Whoa, whoa, wait a minute. Why are we jumping to $003A? Isn't the system routine at $0038??<p>

Well, yes, the Mode 1 interrupt does jump to $0038. What we are doing is swapping the shadow registers when our interrupt is
run, and we want them to stay swapped when the system interrupt is running. A section of the code at $0038 looks like

<pre>
    0038: <span class=ins>JR</span>    $006A
    003A: <span class=ins>IN</span>    <span class=reg>A</span>, (4)
    .
    .
    006A: <span class=ins>EX</span>    <span class=reg>AF</span>, <span class=reg>AF'</span>
    006B: <span class=ins>EXX</span>
    006C: <span class=ins>JR</span>    $003A
</pre>

Yes this is completely redundant, but by jumping to $003A the exchanges get skipped over.<p>

This is useful if you still want <tt>GetKey</tt> and <tt>GetCSC</tt> and other Mode 1 features to work while you're in
Mode 2.<br> Also, if you don't switch back to Mode 1 when the program ends, your interrupt will still be active, even during
graphing and (provided they don't use interrupts themselves) other programs! Unfortunately, drawing and archiving will kill
'em.<p>

    <h3>Program 23-2</h3>
You can use this program instead of masking tape and a sharpie. Test it by pressing [LOG].

<div class=Program>
<pre>
    <span class=ins>DI</span>

<span class=cmt>; We must store the interrupt somewhere in RAM so it sticks around</span>
    <span class=ins>LD</span>     <span class=reg>HL</span>, <span class=mem>interrupt</span>
    <span class=ins>LD</span>     <span class=reg>DE</span>, $9A9A
    <span class=ins>LD</span>     <span class=reg>BC</span>, <span class=mem>interrupt_end</span> - <span class=mem>interrupt</span>
    <span class=ins>LDIR</span>

<span class=cmt>; Don't bother with specific memory locations, 
; just storing $9A everywhere will work</span>
    <span class=ins>LD</span>     <span class=reg>HL</span>, $9900
    <span class=ins>LD</span>     <span class=reg>DE</span>, $9901
    <span class=ins>LD</span>     <span class=reg>BC</span>, 256
    <span class=ins>LD</span>     <span class=reg>(HL)</span>, $9A
    <span class=ins>LDIR</span>

    <span class=ins>LD</span>     <span class=reg>A</span>, $99
    <span class=ins>LD</span>     <span class=reg>I</span>, <span class=reg>A</span>

    <span class=ins>IM</span>     2
    <span class=ins>EI</span>

    <span class=ins>RET</span>

<span class=mem>interrupt:</span>
    <span class=ins>EX</span>     <span class=reg>AF</span>, <span class=reg>AF'</span>
    <span class=ins>EXX</span>

    <span class=ins>LD</span>     <span class=reg>A</span>, $FF
    <span class=ins>OUT</span>    (1), <span class=reg>A</span>

    <span class=ins>LD</span>     <span class=reg>A</span>, $DF
    <span class=ins>OUT</span>    (1), <span class=reg>A</span>

    <span class=ins>IN</span>     <span class=reg>A</span>, (1)
    <span class=ins>CP</span>     $F7
    <span class=ins>JP     NZ</span>, $003A

    <span class=ins>SET</span>    <span class=mem>TextInverse</span>, <span class=reg>(IY + <span class=mem>TextFlags</span>)</span>

    <span class=ins>LD</span>     <span class=reg>HL</span>, <span class=mem>interrupt_message</span> - <span class=mem>interrupt</span> + $9A9A

    <span class=ins>LD</span>     <span class=reg>DE</span>, $3300
    <span class=ins>LD</span>     <span class=mem>(PenCol)</span>, <span class=reg>DE</span>
    b_call(_VPutS)

    <span class=ins>LD</span>     <span class=reg>D</span>, $39
    <span class=ins>LD</span>     <span class=mem>(PenCol)</span>, <span class=reg>DE</span>
    b_call(_VPutS)

    <span class=ins>RES</span>    <span class=mem>TextInverse</span>, <span class=reg>(IY + <span class=mem>TextFlags</span>)</span>

    <span class=ins>JP</span>     $003A

<span class=mem>interrupt_message:</span>
    <span class=dir>.DB</span>    "This TI-83 Plus is property of", 0
    <span class=dir>.DB</span>    "<span class=ins>PUT YOUR NAME HERE!!</span>... HANDS OFF!", 0

<span class=mem>interrupt_end:</span></pre>
</div>

    <hr>
<div class=NavFooter>
    <a href="day22.html">PREVIOUS - Day 22: Low-Level Key Input</a><p>
    <a href="day24.html">NEXT - Day 24: Monochrome Graphics</a><p>
    <a href="toc.html">Table Of Contents</a>
</div>
    <hr>
<address>
This is part of Learn TI-83 Plus Assembly In 28 Days<br>
Copyright (c) 2002, 2003, 2004 Sean McLaughlin<br>
See the file gfdl.html for copying conditions
</address>
<hr>
</body>
</html>